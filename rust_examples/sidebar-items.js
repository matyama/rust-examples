initSidebarItems({"macro":[["approx","Macro that defines “approximately equal” for expressions interpreted as [f64]."],["count","Macro that counts any input tokens at compilation time (i.e. resulting in a `const` value) with no residual memory footprint."],["impl_max_value","Macro that automates implementation of [MaxValue] for arbitrary types having `MAX` member."],["substitute","Simple macro for replacing any token `$_t` with expression `$sub`"]],"mod":[["adts","This module contains an example of Algebraic Data Type (ADT) and the concept of pattern matching which is commonly used to work with ADTs."],["brands","This module demonstrates branded types on an example of a [Vec] with unchecked-indexing."],["collect","This module includes Rust’s implementation of traversable types."],["dependent","This module includes Rust’s approach to dependent types."],["dispatch","This example demonstrates differences between a static dispatch and dynamic dispatch of method calls."],["errors","This module presents several possibilities of how to handle errors in Rust."],["macros","This module contains examples of declarative macros."],["memory","Examples in this module present how the concepts of Ownership and Borrowing work in Rust."],["orphan","This module demonstrates Orphan rules and coherence of Rust’s trait system."],["rc","This module presents various kinds of pointers and their behaviour under [Clone]."],["rsqrt","Example of Fast inverse square root."],["typing","This module shows some examples of how Rust’s type system can be used to write safe yet efficient code."]]});